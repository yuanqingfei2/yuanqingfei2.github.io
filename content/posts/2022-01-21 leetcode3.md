---
title: Leetcode -- 查找
date: "2022-01-22T04:08:00.000Z"
---

## 查找任意一个重复数字

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for(int i = 0; i < nums.length; i++){
            for(int j = i + 1; j < nums.length; j++){
                if(nums[i] == nums[j]){
                    return nums[i];
                }
            }
        }
        return -1;
    }
}
```
时间O(n^2)，空间O(1)，这个方法效率比较低。

官方答案如下：

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        int repeat = -1;
        for (int num : nums) {
            if (!set.add(num)) {
                repeat = num;
                break;
            }
        }
        return repeat;
    }
}
```

时间O(n)，空间O(n)

还有一个更好的答案：

```java
class Solution {    
    public int findRepeatNumber(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; i++){
            int k = nums[i];
            if(k < 0) k += n;
            if(nums[k] < 0) return k;
            nums[k] -= n;
        }
        
        return -1;
    }
};
```

时间是O(n)，空间O(1)，这个方法充分利用题目中所说数字最大时n-1，也就是数组里面的值最大就是下标减一。这样循环时就把值对应的下标的值变成负的，如果没有重复的，遇到这个负值就会再加回来(有可能永远不会再加回来，不过不影响此问题解决)，如果遇到重复的，就会发现对应的那个值的下标的值已经是负的了。从而解决这个问题。

## 统计一个数字在排序数组中出现的次数

```java
class Solution {
    public int search(int[] nums, int target) {
        int count = 0;
        for(int i = 0; i < nums.length; i ++){
            if(nums[i] == target){
                count ++;
            }
        }
        return count;
    }
}
```
这个做法最简单，时间O(n)，空间O(1)，但是没有利用已经排序这个优势条件。

```java
class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 0) return 0;
        return binarySearch(nums, target + 1) - binarySearch(nums, target);
    }

    private int binarySearch(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
}
```

所以正确做法是二分查找，时间O(logn)，空间O(1)，思路就是先查找第一个target的下标，再查找第一个大于此target下标，两者相减即可。

## 查找一个增序其元素唯一的0到n-1数组缺失的数字。

最笨的办法就是逐一检查，如下：

```java
class Solution {
    public int missingNumber(int[] nums) {
        for(int i = 0; i < nums.length + 1; i ++){
            boolean found = false;
            for(int j = 0; j < nums.length; j ++){
                if(nums[j] == i) found = true;
            }
            if(!found) return i;
        }
        return -1;
    }
}
```

时间O(n^2)，空间O(1)，但是这种方法无视了已经排序的提示，应该有更有效的方法。所以还是要二分法

```java
class Solution {
    public int missingNumber(int[] nums) {
        int i = 0, j = nums.length - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] == m) i = m + 1;
            else j = m - 1;
        }
        return i;
    }
}
```
时间O(logn)，空间O(1)